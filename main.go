package main

import (
	"encoding/json"
	"fmt"
	"github.com/tealeg/xlsx"
	"io/ioutil"
	"os"
	"path"
	"strconv"
	"strings"
	"time"
)

type FieldInfo struct {
	index int
	ftype string
	fname string
}

func TrimString(cell *xlsx.Cell) string {
	s, _ := cell.String()
	// return strings.TrimSpace(s)
	return strings.Trim(s, "# ")
}

func IsComment(cell *xlsx.Cell) bool {
	s, _ := cell.String()

	return strings.HasPrefix(s, "#")
}

func ExportJson(sheet *xlsx.Sheet, name string, field_list []FieldInfo) {
	var data []interface{}
	for r := 1; r < sheet.MaxRow; r++ {
		if IsComment(sheet.Cell(r, 0)) {
			continue
		}

		var doc = make(map[string]interface{})
		for _, field := range field_list {
			cell := sheet.Cell(r, field.index)
			switch field.ftype {
			case "string":
				v, e := cell.String()
				if e != nil {
					fmt.Printf("row: %d, col: %d, %s\n", r, field.index, e)
					continue
				}
				doc[field.fname] = v
			case "float32":
				v, e := cell.Float()
				if e != nil {
					fmt.Printf("row: %d, col: %d, %s\n", r, field.index, e)
					continue
				}
				doc[field.fname] = v
			default:
				v, e := cell.Int()
				if e != nil {
					fmt.Printf("row: %d, col: %d, %s\n", r, field.index, e)
					continue
				}
				doc[field.fname] = v
			}
		}
		data = append(data, doc)
	}

	if buf, err := json.Marshal(data); err != nil {
		fmt.Println(err)
	} else {
		var fn string = name + ".json"
		if err := ioutil.WriteFile(fn, buf, 0644); err == nil {
			fmt.Println("Exported", fn, len(data))
		}
	}
}

func ExportSQL(sheet *xlsx.Sheet, name string, field_list []FieldInfo) {
	var data []string
	for r := 1; r < sheet.MaxRow; r++ {
		if IsComment(sheet.Cell(r, 0)) {
			continue
		}

		var values []string
		for _, field := range field_list {
			cell := sheet.Cell(r, field.index)
			switch field.ftype {
			case "string":
				v, e := cell.String()
				if e != nil {
					fmt.Printf("row: %d, col: %d, %s\n", r, field.index, e)
					continue
				}
				values = append(values, "`"+v+"`")
			case "float32":
				v, e := cell.String()
				if e != nil {
					fmt.Printf("row: %d, col: %d, %s\n", r, field.index, e)
					continue
				}
				values = append(values, v)
			default:
				v, e := cell.Int()
				if e != nil {
					fmt.Printf("row: %d, col: %d, %s\n", r, field.index, e)
					continue
				}
				values = append(values, strconv.Itoa(v))
			}
		}

		data = append(data, fmt.Sprintf("(%s)", strings.Join(values, ",")))
	}

	var buf string
	var columns []string
	for _, field := range field_list {
		columns = append(columns, "`"+field.fname+"`")
	}
	buf += fmt.Sprintf("-- Auto generated by kw-data-expoter\n")
	buf += fmt.Sprintf("-- Source: %s\n", sheet.Name)
	buf += fmt.Sprintf("-- Date: %s\n\n", time.Now())

	buf += fmt.Sprintf("DELETE FROM `%s`;\n\n", name)

	buf += fmt.Sprintf("INSERT INTO `%s` (%s) VALUES\n", name, strings.Join(columns, ","))
	buf += strings.Join(data, ",\n")
	buf += ";"

	var fn string = name + ".sql"
	if err := ioutil.WriteFile(fn, []byte(buf), 0644); err == nil {
		fmt.Println("Exported", fn, len(data))
	}
}

func ExportProtoBuf(sheet *xlsx.Sheet, name string, field_list []FieldInfo) {
	var buf string

	buf += fmt.Sprintf("// Auto generated by kw-data-expoter\n")
	buf += fmt.Sprintf("// Source: %s\n", sheet.Name)
	buf += fmt.Sprintf("// Date: %s\n\n", time.Now())

	buf += fmt.Sprintf("message %sData {\n", name)
	buf += fmt.Sprintf("  message %s {\n", name)

	for _, field := range field_list {
		var ftype string
		switch field.ftype {
		case "int16":
			ftype = "int32"
		case "uint16":
			ftype = "uint32"
		default:
			ftype = field.ftype
		}
		buf += fmt.Sprintf("    required %s %s = %d;\n", ftype, field.fname, field.index+1)
	}
	buf += fmt.Sprintf("  }\n\n")

	buf += fmt.Sprintf("  repeated %s data = 1;\n", name)
	buf += fmt.Sprintf("}\n")

	var fn string = name + ".proto"
	if err := ioutil.WriteFile(fn, []byte(buf), 0644); err == nil {
		fmt.Println("Exported", fn)
	}
}

func ExportFile(filename string) {
	fp, err := xlsx.OpenFile(filename)
	if err != nil {
		fmt.Println("OpenFile Error:", filename)
		return
	}

	for _, sheet := range fp.Sheets {
		if sheet.MaxRow < 3 || sheet.MaxCol < 2 {
			continue
		}

		// 컬럼 정보
		var field_list []FieldInfo
		for col := 0; col < sheet.MaxCol; col++ {
			fname := TrimString(sheet.Cell(1, col))
			ftype := TrimString(sheet.Cell(2, col))
			if len(fname) > 0 && len(ftype) > 0 {
				var field FieldInfo
				field.index = col
				field.fname = fname
				field.ftype = ftype

				field_list = append(field_list, field)
			}
		}
		if len(field_list) == 0 {
			continue
		}

		// 이름
		var name string = TrimString(sheet.Cell(0, 1))
		if len(name) == 0 {
			continue
		}

		// 명령어
		switch cmd := TrimString(sheet.Cell(0, 0)); cmd {
		case "json", "JSON":
			ExportJson(sheet, name, field_list)
		case "sql", "SQL":
			ExportSQL(sheet, name, field_list)
		case "protobuf", "PROTOBUF":
			ExportProtoBuf(sheet, name, field_list)
		}
	}
}

func main() {
	// 인자값이 없으면 현재 디렉토리
	var target string = "."
	if len(os.Args) > 1 {
		target = os.Args[1]
	}

	fileinfo, err := os.Stat(target)
	if os.IsNotExist(err) {
		return
	}

	if fileinfo.IsDir() {
		if files, err := ioutil.ReadDir(target); err == nil {
			for _, file := range files {
				if path.Ext(file.Name()) == ".xlsx" && !strings.HasPrefix(file.Name(), "~") {
					ExportFile(path.Join(target, file.Name()))
				}
			}
		}
	} else {
		ExportFile(target)
	}
}
